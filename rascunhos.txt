Entendi! Você está tentando criar uma lista encadeada de structs, onde cada struct guarda uma parte de uma variável (como os parâmetros do ambiente `env` ou outro tipo de dado). O que você quer é usar uma estrutura de lista encadeada para armazenar as structs, onde a quantidade de structs é dinâmica e depende do número de elementos, sem precisar contar quantos elementos são.

Vou explicar um pouco sobre listas encadeadas e depois te mostrar como você pode implementá-las em C para resolver seu problema.

### Estrutura de Lista Encadeada

Uma lista encadeada é uma estrutura de dados em que cada elemento (nodo) possui dois componentes:
1. **Dado**: A informação que você quer armazenar (no seu caso, a struct).
2. **Ponteiro para o próximo elemento**: Esse ponteiro faz com que a lista seja "encadeada", ou seja, o elemento aponta para o próximo, formando uma cadeia de nós.

Para construir uma lista encadeada, você vai usar um ponteiro para o início da lista, que chamamos de **head**.

### Passos:
1. Defina a struct com o tipo de dado que você quer armazenar.
2. Crie uma função para adicionar um novo elemento na lista.
3. Crie uma função para iterar pela lista, se necessário.

Aqui está um exemplo de como você pode fazer isso:

### Exemplo em C

```c
#include <stdio.h>
#include <stdlib.h>
#include <string.h>

// Estrutura para armazenar o dado (por exemplo, uma string ou o env)
typedef struct Node {
    char data[256];   // A parte que você quer armazenar (pode ser qualquer tipo de dado)
    struct Node* next;  // Ponteiro para o próximo nó
} Node;

// Função para criar um novo nó
Node* criarNo(const char* valor) {
    Node* novoNo = (Node*)malloc(sizeof(Node));  // Aloca memória para o novo nó
    if (novoNo == NULL) {
        printf("Erro ao alocar memória!\n");
        return NULL;
    }
    strncpy(novoNo->data, valor, sizeof(novoNo->data) - 1); // Copia o valor
    novoNo->data[sizeof(novoNo->data) - 1] = '\0';  // Garante que a string esteja terminada
    novoNo->next = NULL;  // Inicializa o próximo como NULL
    return novoNo;
}

// Função para adicionar um novo nó no final da lista
void adicionarNo(Node** head, const char* valor) {
    Node* novoNo = criarNo(valor);
    if (novoNo == NULL) {
        return;
    }

    // Se a lista estiver vazia, o novo nó é o head
    if (*head == NULL) {
        *head = novoNo;
    } else {
        Node* temp = *head;
        // Vai até o último nó
        while (temp->next != NULL) {
            temp = temp->next;
        }
        temp->next = novoNo;  // Adiciona o novo nó no final
    }
}

// Função para imprimir a lista
void imprimirLista(Node* head) {
    Node* temp = head;
    while (temp != NULL) {
        printf("%s\n", temp->data);
        temp = temp->next;
    }
}

// Função para liberar a memória da lista
void liberarLista(Node* head) {
    Node* temp;
    while (head != NULL) {
        temp = head;
        head = head->next;
        free(temp);  // Libera a memória do nó
    }
}

int main() {
    Node* head = NULL;  // Inicializa a lista vazia

    // Exemplo de como você pode preencher a lista com partes de dados (como o env)
    adicionarNo(&head, "VAR1=valor1");
    adicionarNo(&head, "VAR2=valor2");
    adicionarNo(&head, "VAR3=valor3");

    // Imprime a lista
    imprimirLista(head);

    // Libera a memória da lista
    liberarLista(head);

    return 0;
}
```

### Explicação do código:
1. **Struct Node**: Cada nó (`Node`) possui um campo `data` para armazenar os dados (como strings do `env`) e um ponteiro `next` para apontar para o próximo nó da lista.
2. **Função `criarNo`**: Cria um novo nó com a informação fornecida e inicializa o ponteiro `next` como `NULL`.
3. **Função `adicionarNo`**: Adiciona um novo nó ao final da lista. Se a lista estiver vazia, o novo nó será o primeiro (head).
4. **Função `imprimirLista`**: Imprime todos os valores armazenados na lista.
5. **Função `liberarLista`**: Libera a memória alocada para cada nó da lista.

### Como funciona o loop:
- **Não é necessário contar quantos elementos você tem**, porque você vai percorrendo a lista até o final. Cada vez que você chama `adicionarNo`, você está criando um novo nó e adicionando-o ao final da lista. O ponteiro `next` de cada nó vai apontar para o próximo nó, e a última posição terá `next = NULL`.
  
Assim, você pode continuar adicionando elementos à lista sem se preocupar com o número de nós, e a memória será alocada dinamicamente.

### Possíveis Melhorias:
- Se você quiser otimizar ainda mais o processo ou tornar a lista mais eficiente (por exemplo, se você precisar acessar rapidamente o primeiro ou último nó), pode implementar uma **lista duplamente encadeada** ou usar um ponteiro para o último nó.
- Além disso, você pode adaptar a `struct Node` para armazenar outros tipos de dados, como inteiros ou structs mais complexas, dependendo do seu caso.

### Próximos Passos:
- Você pode usar esse código para organizar e armazenar diferentes partes de dados em uma lista encadeada, sem precisar saber de antemão quantos elementos você terá.
- Se você tiver mais dúvidas ou precisar de ajuda para integrar com outros dados (como `env`), me avise!